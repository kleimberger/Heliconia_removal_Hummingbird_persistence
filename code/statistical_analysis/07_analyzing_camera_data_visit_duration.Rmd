---
title: "Analyzing visit duration"
output: html_document
knit: (function(inputFile, encoding) {
      out_dir <- "knitted_markdown_files";
      rmarkdown::render(inputFile,
                        encoding=encoding,
                        output_dir=file.path(dirname(inputFile), out_dir))})
---

This is an extra analysis added during peer review.

**Goal:** 

Explore whether there was an experimental effect on sighting length (aka "visit duration", aka how long hummingbird was at inflorescence in camera frame)

**Hypothesis:**

If hummingbirds visited flowers longer after *Heliconia* removal to gain additional calories, then there should be a pre-to-post increase in sighting lengths in treatment replicates (relative to control replicates). This behavioral response would be undetected by the primary response variables.

```{r setup, include = FALSE}
knitr::opts_chunk$set(message = FALSE, warning = FALSE)

#Packages for statistical modeling
library(glmmTMB)
library(AICcmodavg)
library(DHARMa)
library(emmeans)

#Packages for data wrangling
library(dplyr)
library(tidyr)
library(lubridate)
library(purrr)

#Packages for plotting
library(ggplot2)
library(ggrepel)
library(ggpubr)

#Set up parallel processing (likelihood profile CI take forever to run!)
library(future)
plan(multisession)

#Set seed
set.seed(1)
```

## Step 1: Get data

Have already filtered data for analysis in previous script, '02_filtering_summarizing_camera_data'.

Will do some additional filtering here to remove instances of a bird perching on the plant, which would generate extra long sighting ("visit") durations.

Also, some camera sets had >1 plant species in the frame, but the sighting length is for ALL plant species combined. Will not analyze these sightings, because interpretation is a bit awkward; can not interpret results as time spent at each inflorescence of a given plant species. Also, if I keep these sightings, there would be a mismatch between sighting length (for >1 plant species) and the flowers covariate (counted for each plant species).
```{r}
#Get data
data_for_experiment <- read.csv("../../data/export/intermediate/Camera_data_filtered_for_experiment.csv")

#Source helper functions
source("../../code/helper_functions/Calculate_basic_summary_stats.R")
source("../../code/helper_functions/Summarize_camera_data.R")
source("../../code/helper_functions/Modeling_helper_functions.R")
source("../../code/helper_functions/Plotting_helper_functions.R")

#Filter out camera sets with >1 plant species
#Filter out instances of bird perching in frame, based on notes column
#Filter out videos without flower counts; I need to include flowers as a covariate, because expect longer sightings when there are more flowers to visit
single_species_camera_sets <- data_for_experiment %>%
  distinct(year, patch, camera_num, plant_species) %>%
  group_by(year, patch, camera_num) %>%
  summarise(num_species = n()) %>%
  filter(num_species == 1)

data_for_sighting_duration <- data_for_experiment %>%
  left_join(single_species_camera_sets) %>%
  filter(num_species == 1) %>%
  select(-num_species, -X) %>%
  filter(!grepl("perch", sighting_notes, ignore.case = TRUE)) %>%
  filter(sightings_yes_or_no == "Y") %>%
  filter(!is.na(flowers_camera_video)) %>%
  mutate(year_patch = paste(year, patch, sep = "_")) %>%
  mutate(exp_phase = factor(exp_phase, levels = c("pre", "post")))
```

## Step 2: Explore data

What is average sighting length?
```{r}
#Time per sighting (in seconds) - across all bird and plant species
data_for_sighting_duration %>%
  calculate_basic_summary_stats(variable = sighting_length)

#PLOT: Time per sighting (in seconds) - across all bird and plant species
data_for_sighting_duration %>%
  ggplot(aes(x = sighting_length), data = .) +
    geom_histogram(binwidth = 1, center = 0) +
    theme_bw(base_size = 18) +
    labs(x = "Time per sighting (seconds)", y = "Count")
```

## Step 3: Summarize data

These are the same summaries for visitation rate analyses, *except* that I am using a dataset that has sightings with perching filtered out.
```{r}
sighting_durations_all_spp = calculate_sighting_rates(data = data_for_sighting_duration, level_org = "plant_species", level_time = "exp_phase", level_bird = "camera_spp_combined", sightings = "with_visit", include_unknown_spp = FALSE) %>%
  mutate(bird_group = "all_spp") #Replace "camera_spp_combined" with "all_spp"

sighting_durations_greh_visa = calculate_sighting_rates(data = data_for_sighting_duration, level_org = "plant_species", level_time = "exp_phase", level_bird = list(greh_visa = c("GREH", "VISA")), sightings = "with_visit", include_unknown_spp = FALSE)
 
#Combine various summaries
sighting_durations <- sighting_durations_all_spp %>%
  bind_rows(sighting_durations_greh_visa) %>%
  select(bird_group, everything()) %>%
  mutate(time_per_sighting = sightings_time/sightings) #Time is in seconds
```

Not all plants have sightings pre and post; can only analyze changes in sighting duration if both experimental periods have sightings, so need to remove plant species that do not have sightings pre and post
```{r}
#Identify plant species that have sightings during both experimental periods
species_pre_and_post <- sighting_durations %>%
  filter(!is.na(sightings_time)) %>%
  distinct(bird_group, year, patch, control_treatment, plant_species, exp_phase) %>%
  group_by(bird_group, year, patch, control_treatment, plant_species) %>%
  summarise(num_periods = n()) %>%
  ungroup() %>%
  filter(num_periods == 2)

#Filter out species that did not have sightings during both experimental periods
sighting_durations_for_analysis <- sighting_durations %>%
  left_join(species_pre_and_post) %>%
  filter(num_periods == 2) %>%
  select(-num_periods) %>%
  mutate(year_patch = paste(year, patch, sep = "_")) %>%
  mutate(exp_phase = factor(exp_phase, levels = c("pre", "post")))

#Check: are there any NAs in the sighting_duration column?
check01 <- sighting_durations_for_analysis %>%
  filter(is.na(sightings_time))
```

## Step 4: Analyze data

If follow framework used in rest of analyses, I would have 4 models:

1. Heliconia tortuosa (HETO), All hummingbird species
2. Heliconia tortuosa (HETO), Green hermits and Violet sabrewings (Heliconia specialists)
3. All non-HETO plant species, All hummingbird species
4. All non-HETO plant species, Green hermits and Violet sabrewings (Heliconia specialists)

However, here the question is not about visitation rates to HETO vs. non-HETO, so I will analyze all plant species together for simplicity. This approach yields 2 models:

1. All plant species, All hummingbird species
2. All plant species, Green hermits and Violet Sabrewings ("*Heliconia* specialists")

**Model fitting**

For count data, there multiple possible distributions. I need to choose between Poisson and negative binomial (nbinom1 and nbinom2). Also, because the dataset does not include zeroes, I might need a truncated distribution.

ALL HUMMINGBIRD SPECIES
```{r, fig.show='hide', results='hide'}
data_all_spp <- sighting_durations_for_analysis %>%
  filter(bird_group == "all_spp")

m1 <- glmmTMB::glmmTMB(sightings_time ~ control_treatment * exp_phase + log(flowers) + offset(log(sightings)) + (1|patch/year_patch/plant_species), data = data_all_spp, na.action = na.omit, family = "truncated_poisson")

m2 <- glmmTMB::glmmTMB(sightings_time ~ control_treatment * exp_phase + log(flowers) + offset(log(sightings)) + (1|patch/year_patch/plant_species), data = data_all_spp, na.action = na.omit, family = "truncated_nbinom1")

m3 <- glmmTMB::glmmTMB(sightings_time ~ control_treatment * exp_phase + log(flowers) + offset(log(sightings)) + (1|patch/year_patch/plant_species), data = data_all_spp, na.action = na.omit, family = "truncated_nbinom2")

m4 <- glmmTMB::glmmTMB(sightings_time ~ control_treatment * exp_phase + log(flowers) + offset(log(sightings)) + (1|patch/year_patch/plant_species), data = data_all_spp, na.action = na.omit, family = "truncated_genpois")

m5 <- glmmTMB::glmmTMB(sightings_time ~ control_treatment * exp_phase + log(flowers) + offset(log(sightings)) + (1|patch/year_patch/plant_species), data = data_all_spp, na.action = na.omit, family = "poisson")

m6 <- glmmTMB::glmmTMB(sightings_time ~ control_treatment * exp_phase + log(flowers) + offset(log(sightings)) + (1|patch/year_patch/plant_species), data = data_all_spp, na.action = na.omit, family = "nbinom1")

m7 <- glmmTMB::glmmTMB(sightings_time ~ control_treatment * exp_phase + log(flowers) + offset(log(sightings)) + (1|patch/year_patch/plant_species), data = data_all_spp, na.action = na.omit, family = "nbinom2")

m8 <- glmmTMB::glmmTMB(sightings_time ~ control_treatment * exp_phase + log(flowers) + offset(log(sightings)) + (1|patch/year_patch/plant_species), data = data_all_spp, na.action = na.omit, family = "genpois")

#Combine models
model_fitting01 <- tibble(model_name = c("m1", "m2", "m3", "m4", "m5", "m6", "m7", "m8"), model = list(m1, m2, m3, m4, m5, m6, m7, m8)) %>%
  mutate(dharma_object = map(model, ~simulateResiduals(fittedModel = ., n = 1000, plot = FALSE, re.form = ~0))) %>%
  mutate(dharma_plot = pmap(list(dharma_object, model_name), ~make_dharma_plot(dharma_object = ..1, plot_title = ..2,  plot_type = "basic")),
         dharma_zeroinfl_plot = pmap(list(dharma_object, model_name), ~make_dharma_plot(dharma_object = ..1, plot_title = ..2,  plot_type = "zeroinflation")),
         dharma_overdisp_plot = pmap(list(dharma_object, model_name), ~make_dharma_plot(dharma_object = ..1, plot_title = ..2,  plot_type = "overdispersion"))) %>%
  mutate(AICc = map(model, MuMIn::AICc))

#Which model is best according to AIC?
model_fitting01 %>%
  select(model_name, AICc) %>%
  unnest(AICc) %>%
  arrange(AICc)
```

```{r}
#Check to make sure assumptions look OK
#The models with the lowest AICc actually do not look great. nbinom2 (m7) is best in terms of DHARMa plots
model_fitting01$dharma_plot[[7]]
model_fitting01$dharma_zeroinfl_plot[[7]]
model_fitting01$dharma_overdisp_plot[[7]]
```

HELICONIA SPECIALISTS
```{r, fig.show='hide', results='hide'}
data_greh_visa <- sighting_durations_for_analysis %>%
  filter(bird_group == "greh_visa")

m1 <- glmmTMB::glmmTMB(sightings_time ~ control_treatment * exp_phase + log(flowers) + offset(log(sightings)) + (1|patch/year_patch/plant_species), data = data_greh_visa, na.action = na.omit, family = "truncated_poisson")

m2 <- glmmTMB::glmmTMB(sightings_time ~ control_treatment * exp_phase + log(flowers) + offset(log(sightings)) + (1|patch/year_patch/plant_species), data = data_greh_visa, na.action = na.omit, family = "truncated_nbinom1")

m3 <- glmmTMB::glmmTMB(sightings_time ~ control_treatment * exp_phase + log(flowers) + offset(log(sightings)) + (1|patch/year_patch/plant_species), data = data_greh_visa, na.action = na.omit, family = "truncated_nbinom2")

m4 <- glmmTMB::glmmTMB(sightings_time ~ control_treatment * exp_phase + log(flowers) + offset(log(sightings)) + (1|patch/year_patch/plant_species), data = data_greh_visa, na.action = na.omit, family = "truncated_genpois")

m5 <- glmmTMB::glmmTMB(sightings_time ~ control_treatment * exp_phase + log(flowers) + offset(log(sightings)) + (1|patch/year_patch/plant_species), data = data_greh_visa, na.action = na.omit, family = "poisson")

m6 <- glmmTMB::glmmTMB(sightings_time ~ control_treatment * exp_phase + log(flowers) + offset(log(sightings)) + (1|patch/year_patch/plant_species), data = data_greh_visa, na.action = na.omit, family = "nbinom1")

m7 <- glmmTMB::glmmTMB(sightings_time ~ control_treatment * exp_phase + log(flowers) + offset(log(sightings)) + (1|patch/year_patch/plant_species), data = data_greh_visa, na.action = na.omit, family = "nbinom2")

m8 <- glmmTMB::glmmTMB(sightings_time ~ control_treatment * exp_phase + log(flowers) + offset(log(sightings)) + (1|patch/year_patch/plant_species), data = data_greh_visa, na.action = na.omit, family = "genpois")

#Combine models
model_fitting02 <- tibble(model_name = c("m1", "m2", "m3", "m4", "m5", "m6", "m7", "m8"), model = list(m1, m2, m3, m4, m5, m6, m7, m8)) %>%
  mutate(dharma_object = map(model, ~simulateResiduals(fittedModel = ., n = 1000, plot = FALSE, re.form = ~0))) %>%
  mutate(dharma_plot = pmap(list(dharma_object, model_name), ~make_dharma_plot(dharma_object = ..1, plot_title = ..2,  plot_type = "basic")),
         dharma_zeroinfl_plot = pmap(list(dharma_object, model_name), ~make_dharma_plot(dharma_object = ..1, plot_title = ..2,  plot_type = "zeroinflation")),
         dharma_overdisp_plot = pmap(list(dharma_object, model_name), ~make_dharma_plot(dharma_object = ..1, plot_title = ..2,  plot_type = "overdispersion"))) %>%
  mutate(AICc = map(model, MuMIn::AICc))

#Which model is best according to AIC?
model_fitting02 %>%
  select(model_name, AICc) %>%
  unnest(AICc) %>%
  arrange(AICc)
```

```{r}
#Check to make sure assumptions look OK
#The models with the lowest AICc actually do not look great. genpois (m8) is best in terms of DHARMa plots
model_fitting02$dharma_plot[[8]]
model_fitting02$dharma_zeroinfl_plot[[8]]
model_fitting02$dharma_overdisp_plot[[8]]
```

```{r, include=FALSE, eval=FALSE, fig.show='hide', results='hide'}
#Potential analysis option that doesn't use an offset: use average time per sighting as response variable, with normal distribution
gaussian_model <- glmmTMB::glmmTMB(time_per_sighting ~ control_treatment * exp_phase + log(flowers) + (1|patch/year_patch/plant_species), data = data_all_spp, na.action = na.omit, family = "gaussian")
simulateResiduals(gaussian_model) %>% plot() #Nope, looks even worse...
```

```{r, include=FALSE, eval=FALSE, fig.show='hide', results='hide'}
#Potential analysis option that doesn't use an offset: analyze unsummarized data (i.e., 1 row = 1 sighting)
#Remove plant species that do not have sightings pre and post
unsummarized_data_all_spp <- data_for_sighting_duration %>%
  left_join(species_pre_and_post) %>%
  filter(bird_group == "all_spp") %>%
  filter(num_periods == 2) %>%
  select(-num_periods)

#Need a truncated distribution because there are no zeroes for sighting length (always at least 1s)
m1 <- glmmTMB::glmmTMB(sighting_length ~ control_treatment * exp_phase + log(flowers_camera_video) + (1|patch/year_patch/plant_species), data = unsummarized_data_all_spp, na.action = na.omit, family = "truncated_poisson")

m2 <- glmmTMB::glmmTMB(sighting_length ~ control_treatment * exp_phase + log(flowers_camera_video) + (1|patch/year_patch/plant_species), data = unsummarized_data_all_spp, na.action = na.omit, family = "truncated_nbinom1")

m3 <- glmmTMB::glmmTMB(sighting_length ~ control_treatment * exp_phase + log(flowers_camera_video) + (1|patch/year_patch/plant_species), data = unsummarized_data_all_spp, na.action = na.omit, family = "truncated_nbinom2")

m4 <- glmmTMB::glmmTMB(sighting_length ~ control_treatment * exp_phase + log(flowers_camera_video) + (1|patch/year_patch/plant_species), data = unsummarized_data_all_spp, na.action = na.omit, family = "truncated_genpois")

#Combine models
model_fitting03 <- tibble(model_name = c("m1", "m2", "m3", "m4"), model = list(m1, m2, m3, m4)) %>%
  mutate(dharma_object = map(model, ~simulateResiduals(fittedModel = ., n = 1000, plot = FALSE, re.form = ~0))) %>%
  mutate(dharma_plot = pmap(list(dharma_object, model_name), ~make_dharma_plot(dharma_object = ..1, plot_title = ..2,  plot_type = "basic")),
         dharma_zeroinfl_plot = pmap(list(dharma_object, model_name), ~make_dharma_plot(dharma_object = ..1, plot_title = ..2,  plot_type = "zeroinflation")),
         dharma_overdisp_plot = pmap(list(dharma_object, model_name), ~make_dharma_plot(dharma_object = ..1, plot_title = ..2,  plot_type = "overdispersion"))) %>%
  mutate(AICc = map(model, MuMIn::AICc))

#Which model is best according to AIC?
model_fitting03 %>%
  select(model_name, AICc) %>%
  unnest(AICc) %>%
  arrange(AICc)

#Check to make sure assumptions look OK
model_fitting03$dharma_plot[[3]]
model_fitting03$dharma_zeroinfl_plot[[3]]
model_fitting03$dharma_overdisp_plot[[3]]

simulationOutput <- model_fitting03$dharma_object[[3]]

plotResiduals(simulationOutput, unsummarized_data_all_spp$control_treatment)
plotResiduals(simulationOutput, unsummarized_data_all_spp$exp_phase)
plotResiduals(simulationOutput, as.numeric(unsummarized_data_all_spp$flowers_camera_video))

#Test for k-inflation, from DHARMa: https://cran.r-project.org/web/packages/DHARMa/vignettes/DHARMa.html#zero-inflation-k-inflation-or-deficits
countOnes <- function(x) sum(x == 1)  # testing for number of 1s
testGeneric(simulationOutput, summary = countOnes, alternative = "less") # "greater" = inflation, "less" = deficit

countTwos <- function(x) sum(x == 2)  # testing for number of 2s
testGeneric(simulationOutput, summary = countTwos, alternative = "greater")

countThrees <- function(x) sum(x == 3)  # testing for number of 3s
testGeneric(simulationOutput, summary = countThrees, alternative = "greater") 

countFours <- function(x) sum(x == 4)  # testing for number of 4s
testGeneric(simulationOutput, summary = countFours, alternative = "greater") 

countFives <- function(x) sum(x == 5)  # testing for number of 5s
testGeneric(simulationOutput, summary = countFives, alternative = "greater")

#Seems like a tough dataset to analyze without using offset. Fewer 1s than expected but more of other numbers.
```

**Compile results**
```{r}
model_all_spp <- model_fitting01$model[[7]]
model_greh_visa <- model_fitting02$model[[8]]

#Model summaries
results_tidy <- broom.mixed::tidy(model_all_spp) %>%
  mutate(bird_group = "all_spp") %>%
  bind_rows(broom.mixed::tidy(model_greh_visa)) %>%
  mutate(bird_group = ifelse(is.na(bird_group), "greh_visa", bird_group)) %>%
  select(bird_group, everything()) %>%
  mutate(pvalue_round = format.pval(pv = round(p.value, 3), digits = 3, nsmall = 3, eps = 0.001)) %>%
  mutate(across(c(estimate, std.error, statistic), ~round(., digits = 3))) %>%
  select(-p.value)

#Estimated marginal means
#Bias adjustment using random effect SDs
bias_adjust_values <- results_tidy %>%
  filter(effect == "ran_pars") %>%
  mutate(estimate2 = estimate^2) %>%
  group_by(bird_group) %>%
  summarise(sum_estimate2 = sum(estimate2)) %>%
  ungroup() %>%
  mutate(sigma = sqrt(sum_estimate2))

sigma_all_spp <- filter(bias_adjust_values, bird_group == "all_spp") %>% pull(sigma)
sigma_greh_visa <- filter(bias_adjust_values, bird_group == "greh_visa") %>% pull(sigma)

#Offset of 1 gives the average sighting length (i.e., estimated amount of time, in seconds, for 1 sighting)
(emmeans_all_spp <- emmeans(model_all_spp, specs = ~exp_phase:control_treatment, type = "response", offset = log(1), bias.adjust = TRUE, sigma = sigma_all_spp) %>%
  as.data.frame() %>%
  rename(estimate = response) %>%
  mutate_if(is.numeric, ~round(., digits = 2)))

(emmeans_greh_visa <- emmeans(model_greh_visa, specs = ~exp_phase:control_treatment, type = "response", offset = log(1), bias.adjust = TRUE, sigma = sigma_greh_visa) %>%
  as.data.frame() %>%
  rename(estimate = response) %>%
  mutate_if(is.numeric, ~round(., digits = 2)))
```

**Plot results (interaction plots)**
```{r, fig.width=5, fig.height=5, fig.align='center'}
#Sizes for plot elements
size = 12
label_size = size
title_size = size * 1.15
shape_size = 2
line_width = 1

#Plots
plot_all_spp <- make_interaction_plot(emmeans_df = emmeans_all_spp, yvar = "visit_duration", ymin = 6, ymax = 12, ybreak = 1, yaccuracy = 1, text_size = size, point_size = shape_size, line_size = line_width, ylabel = "Visit duration (seconds)")

plot_greh_visa <- make_interaction_plot(emmeans_df = emmeans_greh_visa, yvar = "visit_duration", ymin = 6, ymax = 12, ybreak = 1, yaccuracy = 1, text_size = size, point_size = shape_size, line_size = line_width, ylabel = "Visit duration (seconds)")

#Combine into one plot
multiplot <- ggarrange(plot_all_spp, plot_greh_visa, nrow = 2, common.legend = TRUE, legend = "bottom", labels = c("(a)", "(b)"), font.label = list(size = label_size, face = "plain"), label.x = 0.08, label.y = 0.96)

multiplot
```

**Export results**
```{r}
#SUMMARY TABLES
path_name <- c("../../results/statistical_analysis/tables")

#All results tables
write.csv(results_tidy, file.path(path_name, "Hummingbird_visit_duration_results_model_summaries.csv"))
```

